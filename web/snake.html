<!DOCTYPE html>
<html lang="tr">

<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0, user-scalable=no">
    <title>Snake - Vira</title>
    <script src="https://telegram.org/js/telegram-web-app.js"></script>
    <style>
        :root {
            --bg-primary: #0f0f23;
            --bg-secondary: #1a1a2e;
            --bg-card: #16213e;
            --accent: #e94560;
            --snake-color: #00d26a;
            --food-color: #ff6b6b;
            --text-primary: #ffffff;
            --text-secondary: #a0a0b0;
        }

        .light-theme {
            --bg-primary: #f0f0f0;
            --bg-secondary: #ffffff;
            --bg-card: #ffffff;
            --text-primary: #1a1a2e;
            --text-secondary: #666666;
        }

        * {
            margin: 0;
            padding: 0;
            box-sizing: border-box;
            -webkit-tap-highlight-color: transparent;
        }

        body {
            font-family: 'Segoe UI', Tahoma, Geneva, Verdana, sans-serif;
            background: var(--bg-primary);
            color: var(--text-primary);
            min-height: 100vh;
            display: flex;
            flex-direction: column;
            align-items: center;
            padding: 10px;
            overflow: hidden;
        }

        .header {
            display: flex;
            align-items: center;
            gap: 12px;
            margin-bottom: 10px;
        }

        .header img {
            width: 40px;
            height: 40px;
            border-radius: 50%;
        }

        .header h1 {
            font-size: 1.8rem;
            background: linear-gradient(135deg, var(--accent), #ff6b8a);
            -webkit-background-clip: text;
            -webkit-text-fill-color: transparent;
            background-clip: text;
        }

        .stats-bar {
            display: flex;
            gap: 20px;
            margin-bottom: 10px;
        }

        .stat-item {
            background: var(--bg-card);
            padding: 8px 16px;
            border-radius: 20px;
            font-size: 0.9rem;
        }

        .stat-value {
            font-weight: bold;
            color: var(--snake-color);
        }

        .game-container {
            background: var(--bg-card);
            padding: 8px;
            border-radius: 15px;
            box-shadow: 0 10px 40px rgba(0, 0, 0, 0.3);
        }

        #game-canvas {
            display: block;
            border-radius: 10px;
            background: var(--bg-secondary);
        }

        .controls {
            display: grid;
            grid-template-columns: repeat(3, 1fr);
            gap: 8px;
            margin-top: 15px;
            width: 180px;
        }

        .ctrl-btn {
            width: 55px;
            height: 55px;
            border: none;
            border-radius: 15px;
            font-size: 1.5rem;
            cursor: pointer;
            background: var(--bg-card);
            color: var(--text-primary);
            box-shadow: 0 4px 15px rgba(0, 0, 0, 0.2);
            transition: all 0.15s;
            display: flex;
            align-items: center;
            justify-content: center;
        }

        .ctrl-btn:active {
            transform: scale(0.9);
            background: var(--accent);
        }

        .ctrl-btn.empty {
            visibility: hidden;
        }

        .game-over-overlay {
            position: fixed;
            top: 0;
            left: 0;
            width: 100%;
            height: 100%;
            background: rgba(0, 0, 0, 0.85);
            display: none;
            align-items: center;
            justify-content: center;
            z-index: 1000;
        }

        .game-over-overlay.show {
            display: flex;
        }

        .game-over-content {
            background: var(--bg-card);
            padding: 30px;
            border-radius: 20px;
            text-align: center;
        }

        .game-over-content h2 {
            font-size: 2rem;
            color: var(--accent);
            margin-bottom: 10px;
        }

        .game-over-content .final-score {
            font-size: 3rem;
            color: var(--snake-color);
            font-weight: bold;
        }

        .play-btn {
            margin-top: 20px;
            padding: 15px 40px;
            border: none;
            border-radius: 25px;
            font-size: 1.1rem;
            font-weight: 600;
            cursor: pointer;
            background: linear-gradient(135deg, var(--accent), #ff6b8a);
            color: white;
        }

        .start-overlay {
            position: fixed;
            top: 0;
            left: 0;
            width: 100%;
            height: 100%;
            background: rgba(0, 0, 0, 0.9);
            display: flex;
            align-items: center;
            justify-content: center;
            z-index: 1000;
        }

        .start-overlay.hidden {
            display: none;
        }

        .start-content {
            text-align: center;
        }

        .start-content h2 {
            font-size: 2.5rem;
            margin-bottom: 20px;
        }

        .start-content p {
            color: var(--text-secondary);
            margin-bottom: 30px;
        }
    </style>
</head>

<body>
    <div class="header">
        <img src="vira_logo.png" alt="Vira">
        <h1>üêç Snake</h1>
    </div>

    <div class="stats-bar">
        <div class="stat-item">
            Skor: <span class="stat-value" id="score">0</span>
        </div>
        <div class="stat-item">
            En Y√ºksek: <span class="stat-value" id="high-score">0</span>
        </div>
    </div>

    <div class="game-container">
        <canvas id="game-canvas"></canvas>
    </div>

    <div class="controls">
        <div class="ctrl-btn empty"></div>
        <button class="ctrl-btn" id="btn-up">‚¨ÜÔ∏è</button>
        <div class="ctrl-btn empty"></div>
        <button class="ctrl-btn" id="btn-left">‚¨ÖÔ∏è</button>
        <button class="ctrl-btn" id="btn-down">‚¨áÔ∏è</button>
        <button class="ctrl-btn" id="btn-right">‚û°Ô∏è</button>
    </div>

    <div class="start-overlay" id="start-overlay">
        <div class="start-content">
            <h2>üêç Snake</h2>
            <p>Yemi ye, b√ºy√º!<br>Duvarlara ve kendine √ßarpma!</p>
            <button class="play-btn" onclick="startGame()">‚ñ∂Ô∏è Ba≈üla</button>
        </div>
    </div>

    <div class="game-over-overlay" id="game-over">
        <div class="game-over-content">
            <h2>Oyun Bitti!</h2>
            <div class="final-score" id="final-score">0</div>
            <p>puan kazandƒ±n</p>
            <button class="play-btn" onclick="restartGame()">üîÑ Tekrar Oyna</button>
        </div>
    </div>

    <script>
        const tg = window.Telegram?.WebApp;
        if (tg) {
            tg.ready();
            tg.expand();
            if (tg.colorScheme === 'light') {
                document.body.classList.add('light-theme');
            }
        }

        // --- LANGUAGE & API SETUP ---
        const urlParams = new URLSearchParams(window.location.search);
        const lang = urlParams.get('lang') || 'en';

        const TEXTS = {
            tr: {
                title: 'üêç Snake',
                score: 'Skor',
                highScore: 'En Y√ºksek',
                startTitle: 'üêç Snake',
                startDesc: 'Yemi ye, b√ºy√º!<br>Duvarlara ve kendine √ßarpma!',
                startBtn: '‚ñ∂Ô∏è Ba≈üla',
                gameOver: 'Oyun Bitti!',
                won: 'puan kazandƒ±n',
                restart: 'üîÑ Tekrar Oyna'
            },
            en: {
                title: 'üêç Snake',
                score: 'Score',
                highScore: 'Best',
                startTitle: 'üêç Snake',
                startDesc: 'Eat food, grow!<br>Avoid walls and yourself!',
                startBtn: '‚ñ∂Ô∏è Start',
                gameOver: 'Game Over!',
                won: 'points scored',
                restart: 'üîÑ Play Again'
            },
            ru: {
                title: 'üêç Snake',
                score: '–°—á—ë—Ç',
                highScore: '–†–µ–∫–æ—Ä–¥',
                startTitle: 'üêç –ó–º–µ–π–∫–∞',
                startDesc: '–ï—à—å –µ–¥—É, —Ä–∞—Å—Ç–∏!<br>–ù–µ –≤—Ä–µ–∑–∞–π—Å—è –≤ —Å—Ç–µ–Ω—ã!',
                startBtn: '‚ñ∂Ô∏è –°—Ç–∞—Ä—Ç',
                gameOver: '–ò–≥—Ä–∞ –û–∫–æ–Ω—á–µ–Ω–∞!',
                won: '–æ—á–∫–æ–≤ –Ω–∞–±—Ä–∞–Ω–æ',
                restart: 'üîÑ –ò–≥—Ä–∞—Ç—å —Å–Ω–æ–≤–∞'
            }
        };

        const t = TEXTS[lang] || TEXTS['en'];

        // Apply translations
        document.querySelector('.header h1').innerText = t.title;
        document.querySelector('#score').previousSibling.textContent = t.score + ': ';
        document.querySelector('#high-score').previousSibling.textContent = t.highScore + ': ';
        document.querySelector('.start-content h2').innerText = t.startTitle;
        document.querySelector('.start-content p').innerHTML = t.startDesc;
        document.querySelector('.start-content button').innerText = t.startBtn;
        document.querySelector('.game-over-content h2').innerText = t.gameOver;
        document.querySelector('.game-over-content p').innerText = t.won;
        document.querySelector('.game-over-content button').innerText = t.restart;

        // API Handler
        async function saveScore(score) {
            console.log("Saving score:", score);
            if (!tg) return;

            try {
                const response = await fetch('/api/save_score', {
                    method: 'POST',
                    headers: { 'Content-Type': 'application/json' },
                    body: JSON.stringify({
                        initData: tg.initData,
                        game: 'snake',
                        score: score
                    })
                });
                const data = await response.json();
                if (data.new_high_score) {
                    if (tg.HapticFeedback) tg.HapticFeedback.notificationOccurred('success');
                }
            } catch (e) {
                console.error("Save score error:", e);
            }
        }

        const canvas = document.getElementById('game-canvas');
        const ctx = canvas.getContext('2d');

        // Responsive canvas
        const size = Math.min(window.innerWidth - 40, 340);
        canvas.width = size;
        canvas.height = size;

        const gridSize = 17;
        const cellSize = Math.floor(size / gridSize);

        let snake = [];
        let food = {};
        let direction = 'right';
        let nextDirection = 'right';
        let score = 0;
        let highScore = parseInt(localStorage.getItem('snake_high') || '0');
        let gameLoop = null;
        let gameStarted = false;

        document.getElementById('high-score').textContent = highScore;

        function initGame() {
            snake = [
                { x: 5, y: 8 },
                { x: 4, y: 8 },
                { x: 3, y: 8 }
            ];
            direction = 'right';
            nextDirection = 'right';
            score = 0;
            document.getElementById('score').textContent = score;
            spawnFood();
        }

        function spawnFood() {
            do {
                food = {
                    x: Math.floor(Math.random() * gridSize),
                    y: Math.floor(Math.random() * gridSize)
                };
            } while (snake.some(s => s.x === food.x && s.y === food.y));
        }

        function draw() {
            // Clear
            ctx.fillStyle = getComputedStyle(document.body).getPropertyValue('--bg-secondary');
            ctx.fillRect(0, 0, canvas.width, canvas.height);

            // Grid (subtle)
            ctx.strokeStyle = 'rgba(255,255,255,0.03)';
            for (let i = 0; i <= gridSize; i++) {
                ctx.beginPath();
                ctx.moveTo(i * cellSize, 0);
                ctx.lineTo(i * cellSize, canvas.height);
                ctx.stroke();
                ctx.beginPath();
                ctx.moveTo(0, i * cellSize);
                ctx.lineTo(canvas.width, i * cellSize);
                ctx.stroke();
            }

            // Food
            ctx.fillStyle = '#ff6b6b';
            ctx.beginPath();
            ctx.arc(
                food.x * cellSize + cellSize / 2,
                food.y * cellSize + cellSize / 2,
                cellSize / 2 - 2,
                0, Math.PI * 2
            );
            ctx.fill();

            // Snake
            snake.forEach((segment, index) => {
                const gradient = ctx.createRadialGradient(
                    segment.x * cellSize + cellSize / 2,
                    segment.y * cellSize + cellSize / 2,
                    0,
                    segment.x * cellSize + cellSize / 2,
                    segment.y * cellSize + cellSize / 2,
                    cellSize / 2
                );

                if (index === 0) {
                    gradient.addColorStop(0, '#00ff88');
                    gradient.addColorStop(1, '#00d26a');
                } else {
                    const alpha = 1 - (index / snake.length) * 0.4;
                    gradient.addColorStop(0, `rgba(0, 210, 106, ${alpha})`);
                    gradient.addColorStop(1, `rgba(0, 180, 90, ${alpha})`);
                }

                ctx.fillStyle = gradient;
                ctx.beginPath();
                ctx.roundRect(
                    segment.x * cellSize + 1,
                    segment.y * cellSize + 1,
                    cellSize - 2,
                    cellSize - 2,
                    4
                );
                ctx.fill();

                // Eyes on head
                if (index === 0) {
                    ctx.fillStyle = 'white';
                    const eyeOffset = cellSize / 4;
                    const eyeSize = 3;

                    if (direction === 'right') {
                        ctx.beginPath();
                        ctx.arc(segment.x * cellSize + cellSize - 5, segment.y * cellSize + eyeOffset, eyeSize, 0, Math.PI * 2);
                        ctx.arc(segment.x * cellSize + cellSize - 5, segment.y * cellSize + cellSize - eyeOffset, eyeSize, 0, Math.PI * 2);
                        ctx.fill();
                    } else if (direction === 'left') {
                        ctx.beginPath();
                        ctx.arc(segment.x * cellSize + 5, segment.y * cellSize + eyeOffset, eyeSize, 0, Math.PI * 2);
                        ctx.arc(segment.x * cellSize + 5, segment.y * cellSize + cellSize - eyeOffset, eyeSize, 0, Math.PI * 2);
                        ctx.fill();
                    } else if (direction === 'up') {
                        ctx.beginPath();
                        ctx.arc(segment.x * cellSize + eyeOffset, segment.y * cellSize + 5, eyeSize, 0, Math.PI * 2);
                        ctx.arc(segment.x * cellSize + cellSize - eyeOffset, segment.y * cellSize + 5, eyeSize, 0, Math.PI * 2);
                        ctx.fill();
                    } else {
                        ctx.beginPath();
                        ctx.arc(segment.x * cellSize + eyeOffset, segment.y * cellSize + cellSize - 5, eyeSize, 0, Math.PI * 2);
                        ctx.arc(segment.x * cellSize + cellSize - eyeOffset, segment.y * cellSize + cellSize - 5, eyeSize, 0, Math.PI * 2);
                        ctx.fill();
                    }
                }
            });
        }

        function update() {
            direction = nextDirection;

            const head = { x: snake[0].x, y: snake[0].y };

            switch (direction) {
                case 'up': head.y--; break;
                case 'down': head.y++; break;
                case 'left': head.x--; break;
                case 'right': head.x++; break;
            }

            // Check collision with walls
            if (head.x < 0 || head.x >= gridSize || head.y < 0 || head.y >= gridSize) {
                gameOver();
                return;
            }

            // Check collision with self
            if (snake.some(s => s.x === head.x && s.y === head.y)) {
                gameOver();
                return;
            }

            snake.unshift(head);

            // Check food
            if (head.x === food.x && head.y === food.y) {
                score += 10;
                document.getElementById('score').textContent = score;
                spawnFood();

                if (tg?.HapticFeedback) {
                    tg.HapticFeedback.impactOccurred('light');
                }
            } else {
                snake.pop();
            }

            draw();
        }

        function gameOver() {
            clearInterval(gameLoop);
            gameStarted = false;

            if (score > highScore) {
                highScore = score;
                localStorage.setItem('snake_high', highScore);
                document.getElementById('high-score').textContent = highScore;
            }

            // Save to server
            saveScore(score);

            document.getElementById('final-score').textContent = score;
            document.getElementById('game-over').classList.add('show');

            if (tg?.HapticFeedback) {
                tg.HapticFeedback.notificationOccurred('error');
            }
        }

        function startGame() {
            document.getElementById('start-overlay').classList.add('hidden');
            initGame();
            draw();
            gameStarted = true;
            gameLoop = setInterval(update, 120);
        }

        function restartGame() {
            document.getElementById('game-over').classList.remove('show');
            initGame();
            draw();
            gameStarted = true;
            gameLoop = setInterval(update, 120);
        }

        function changeDirection(newDir) {
            if (!gameStarted) return;

            const opposites = { up: 'down', down: 'up', left: 'right', right: 'left' };
            if (opposites[newDir] !== direction) {
                nextDirection = newDir;
                if (tg?.HapticFeedback) {
                    tg.HapticFeedback.impactOccurred('light');
                }
            }
        }

        // Controls
        document.getElementById('btn-up').onclick = () => changeDirection('up');
        document.getElementById('btn-down').onclick = () => changeDirection('down');
        document.getElementById('btn-left').onclick = () => changeDirection('left');
        document.getElementById('btn-right').onclick = () => changeDirection('right');

        // Keyboard
        document.addEventListener('keydown', (e) => {
            const keys = { ArrowUp: 'up', ArrowDown: 'down', ArrowLeft: 'left', ArrowRight: 'right' };
            if (keys[e.key]) {
                e.preventDefault();
                changeDirection(keys[e.key]);
            }
        });

        // Swipe
        let touchStartX = 0, touchStartY = 0;
        canvas.addEventListener('touchstart', (e) => {
            touchStartX = e.touches[0].clientX;
            touchStartY = e.touches[0].clientY;
        });
        canvas.addEventListener('touchend', (e) => {
            const dx = e.changedTouches[0].clientX - touchStartX;
            const dy = e.changedTouches[0].clientY - touchStartY;

            if (Math.abs(dx) > Math.abs(dy)) {
                changeDirection(dx > 0 ? 'right' : 'left');
            } else {
                changeDirection(dy > 0 ? 'down' : 'up');
            }
        });

        // Initial draw
        initGame();
        draw();
    </script>
</body>

</html>